# warmup_project

## drive_square.py write up
1. In this portion of the project I intended on making my robot go in a straight line and then turn, both happening for a given period of time. In order to make my robot trace out a square I first created a function that defined the linear motion of the robot. The idea was to get my robot to move foward for about 1 second with no angular velocity and then stop. I then defined a function for the angular motion of the robot which is to be executed after the linear function for about second1 and then stop. Over 4 iterations of these two functions my robot would move and turn to make a square.
2. My first function is called linear and is part of the Big square class. I initialized a linear velocity and an angular velocity where my angular velocity is set to zero. I then set up a for loop that iterates through the publish call. I added a sleep call before the publisher to account for lag and then a sleep function after to allow for my next function to run. My second function is called turn also part of the Big square function where I used the same methology as my linear function but instead I kept the angular velocity as nonzero. My last function is the run function which calls my frist two functions and I do this in a four loop so that it repeats 4 times to make a square.
3. GIF:

![drive_square.GIF.gif](https://github.com/Meganmm1/warmup_project/blob/e83638efbfc3c7371ba83877639ef50a77c08a21/drive_square.GIF.gif)



## person_follower.py write up
1. In this portion of the project I intended for my robot to follow a person. I approached this problem by storing the angle at which the closest object to the robot was at (by using a for loop that scans all the possible angles and stores the smallest value), and then adjusting the linear and angular speed depending on that angle. I defined a minimal distance from the person to the robot that I wanted to keep. If the robot was at this distance then it wouldnt move, if it was farther than the distance, it would move foward (while adjusting angular speed) and if it was closer than the distance it would back up. 
2. In this project I only defined one callback function with different conditionals. My first conditional defined a case for which there was no person to follow then the robot would stay put. My second conditional ensured that the robot would move toward an object directly infront of it, where a range of angles were defined to account for error. My third conditional defines a case where the robot is farther than the fixed distance I set from the person, in which case the robot would move toward and turn depending on the angle at which the person is at. By using proportional control for the angular speed it is ensured that the person stays infront of robot. My fourth conditional ensures that the robot backs away if it passes the fixed distance between it and the person while also using porportional control for the angular speed. My final conditions ensures that if the robot and person are at the fixed distance then the robot won't move.

3. GIF:

![person_follower.GIF](https://github.com/Meganmm1/warmup_project/blob/0b2ed5f3e00290cb3c84a1653d18a9788f3e4e52/person_follower.GIF)

## wall_follower.py write up
1. The way I decided to approach this portion of the project is have the robot move along a fixed distance from the wall while also maintaining this fixed distance at a fixed angle. I was able to do this by implementing proportional control to have the closest object always be at an angle of 270 degrees, if not the robot would move so that the closest object (at the fixed distance) ends up at this lcoation.
2. I only created one call back function which included different conditions. My first condition consisted accounting for the robot in a vast room it would slowly move foward until it located a wall. The second condition consist of the robot being farther than the fixed distance from the wall in which case it would move foward and be oriented so that the wall is directly infront of the robot. The third condition ensures that if the robot is directly facing the wall then it will turn so that the wall becomes located at an angle of 270 degrees in relation to the robot. The fourth condition offers a range of values that are meant to move the robot foward is the wall is at or near an angle of 270 degrees. The fifth condition is meant to handle the case that if the robot is tilted to the right (the wall is located at an angle less than 270) then the robot will tilt left so that 270 becomes the angle at while the wall is at. The sixth condition ensure that if the robot is tilted left (wall at an angle greater than 270) then the robot will turn to the right. The last condition is meant to handle the case where the robot is too close to the wall where it takes into account proportional control, allowing for the robot to move backwards if it passes the fixed distance. 
3. GIF:  
![wall_follower.gif.GIF](https://github.com/Meganmm1/warmup_project/blob/46de452bd294966d1a6fdc59b58d5dfada65aa86/wall_follower.GIF.gif)


## CHALLANGES 
One of the main challanges that I encountered in this project dealt with understanding and getting accustomed to using the sensor on the robot. In the person follower there was an instance where my robot would accurately be able to detect where I was but would spin before following me in a straight line. I fixed this issue by creating an extra conditional that specified if there was an object in front of the robot then the robot would move straight without any angular velocity.
On this same note in my wall follower code the case where my robot got too close to the wall got complicated as the robot would reach the wall but not execute the move away condition I defined. I fixed this by using proportional control for both the linear and angular velocities but my robot however followed a line backwards as well rather than always following the wall facing foward. The robot was able to correctly follow along the wall but I was not able to determine how the angles needed to be implememted to allow for the robot to move foward in all cases, showing this as a challange that is still in the process of solving.

## FUTURE WORK
- For drive in a square if I had more time I would implemet an end case for my robot that that it would stop in place. Based off the code I implemented, my robot drives in a square and then once it has finished will keep spinning in a circle. Rather then having it spin I would make it come to an end. 
- For the person follower if I had more time I would implement proportional control for the linear distance as well as the angular distance so that my robot would speed up and slow down in accordance to how close and far away they are from a person. I would also try and specify more angle conditions so that when my robot turns to follow a person it takes the shortest turning distance rather than always having to turn clockwise.
- For wall follower if I had more time I would try and pay closer attention to the case where the robot is at a corner and exactly the same distance from two different walls in which case my current robot does not know how to handle the situation and would stay in the same spot. I would also play closer attention to the way in which my robot identified corners where my current robot will follow a wall but at times turns multiple times before reorinetating itself in the proper direction.

## TAKEAWAYS
- Proportional control == friend: When I originally began this project I did not think to implement proportional control and for many of the angle cases was gonna try and calculate a rate for which my robot should turn but this method turned out to be alot more complicated than I had anticipated. By incorporating proportional control I was able to implemet an easier method at the same time that my robot robot was able to more accurately turn to follow a person and a wall with precision. 
- Print statements are useful for debugging: For both the person follower and the wall follower I was incorrectly incorporating else if statments that made some of my conditionals not get accessed. I tried adapting the rostopic echo command but so many values printed out that it was not helpful in helping me debug. When I started incorporating print statements I was able to see what part of my code my robot was executing and correctly fix the issues as a result. 

